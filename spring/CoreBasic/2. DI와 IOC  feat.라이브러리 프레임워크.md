# 2. DI와 IOC

출처: [스프링 핵심원리 - 기본편](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/dashboard)

## DI(의존관계 주입)

어플리케이션의 **실행시점(런타임)** 에 외부에서 의존하는 실제 구현 객체를 생성하고 클라이언트(해당 객체를 의존하고있는 클래스)에 전달하여 의존관계가 연결되는 것

* **정적인 클래스 의존관계**: 어플리케이션을 실행하지 않고 import만 보고 판단할 수 있는 의존관계. 인터페이스에 의존하고 있기때문에 실제 어떤 구현체가 주입될지 알 수 없다.
* **동적인 클래스 의존관계**: 어플리케이션 실행 시점에 실제 생성된 구현객체 인스턴스의 참조가 연결된 의존관계

#### DI 사용시 이점
* 클라이언트코드(ex) ~ServiceImpl의 코드)를 변경하지 않고 실제 호출하는 구현인스턴스를 변경할 수 있다.
* 정적인 클래스 의존관계를 변경하지 않고 확장가능.

<br>

## IOC(제어의 역전)

프로그램의 제어 흐름(ex: 메소드나 객체의 호출작업)을 개발자가 결정하는 것이 아니라, 외부에서 관리하는 것.

즉 개발자가 Member member = new Member();와 같이 객체를 직접 생성하는것이 아니라 **스프링이 객체를 생성**해서 필요한 곳에 사용할수 있게 도와줌 

* 객체를 생성하고 연결하는 역할을 하는 AppConfig 클래스가 있다고 가정
* 이후 ~ServiceImpl과 같은 구현객체는 자신의 로직을 실행하는 역할만 담당
  * 필요한 인터페이스들을 호출하지만 어떤 구현체가 실행될지는 모른다
  * 어떤 구현체가 실행될지는 AppConfig가 결정
* 위처럼 프로그램의 제어흐름을 외부에서 관리하는 것을 IOC라 한다

#### 프레임워크 vs 라이브러리

* 프레임워크: 내가 작성한 코드를 프레임워크가 제어하고 대신 실행한다
* 라이브러리: 내가 작성한 코드가 직접 제어의 흐름을 담당한다

**DI도 IOC에 포함되는 기술이며, IOC가 좀 더 광범위하게 사용**














