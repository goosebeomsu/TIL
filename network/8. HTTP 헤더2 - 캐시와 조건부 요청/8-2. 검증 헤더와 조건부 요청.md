# 8-2. 검증 헤더와 조건부 요청
 
 출처: [모든 개발자를 위한 HTTP 웹 기본 지식](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/dashboard)
 
**캐시 유효 시간이 초과해서 서버에 다시 요청할때 두가지 경우**

 1. 서버에서 기존 데이터 변경 X
 2. 서버에서 기존 데이터 변경

## 검증헤더 & 조건부 요청

* **검증 헤더**
  * 캐시 시간이 초과 되었어도 데이터가 같기 때문에 저장해 두었던 캐시를 재사용 하는 것이 효율적
  * 클라이언트의 캐시 데이터와 서버의 데이터가 같다는 사실을 확인할 방법이 필요 => **검증 헤더 사용**
  * Last-Modified , ETag
  
* **조건부 요청 헤더**
  * 검증 헤더로 조건에 따른 분기
  * If-Modified-Since: Last-Modified 사용
  * If-None-Match: ETag 사용
  * 조건이 만족하면 200 OK
  * 조건이 만족하지 않으면 304 Not Modified

 <br>

## 서버에서 기존 데이터 변경 X


![image](https://user-images.githubusercontent.com/83762364/181602903-9a126ab8-5b67-4a34-8f04-951df3a15de0.png)

1. 서버는 클라이언트 요청에 응답할때 Last-Modified라는 검증헤더를 통해 데이터 최종 수정일에 대한 정보를 추가하여 응답을 보냄
2. 클라이언트는 데이터 최종 수정일에 대한 정보를 포함한 응답 결과를 캐시에 저장
3. 캐시 시간 초과후 클라이언트에서 요청을 보낼때 **if-modified-since:(데이터 최종 수정일)** 를 통해 요청
4. 클라이언트와 서버의 데이터 최종 수정일이 일치하면 **HTTP BODY없이 304 Not Modified + 헤더 메타 정보** 만 응답
5. 클라이언트는 응답 헤더 정보로 캐시의 메타 정보를 갱신
6. 클라이언트는 캐시에 저장되어 있는 데이터를 재활용 => **서버가 HTTP BODY없이 응답하기 때문에 데이터 전송량이 훨씬 적음**

<br>

## Last-Modified, If-Modified-Since 단점

* 1초 미만(0.x초) 단위로 캐시 조정이 불가능
* 날짜 기반의 로직 사용
* 데이터를 수정해서 날짜가 다르지만, 같은 데이터를 수정해서 데이터 결과가 똑같은 경우에도 데이터를 다시 받아야함
* 서버에서 별도의 캐시 로직을 관리하고 싶은 경우
  * 예) 스페이스나 주석처럼 크게 영향이 없는 변경에서 캐시를 유지하고 싶은 경우

## ETag, If-None-Match

 * ETag
   * 캐시용 데이터에 임의의 고유한 버전 이름을 달아둠
   * 이름이 데이터에 따라 생성된 Hash값 => 데이터가 변경되면 이름이 바뀜, 데이터가 같으면 이름도 같음

#### ETag, If-None-Match 사용

 * 단순하게 ETag만 서버에 보내서 같으면 유지, 다르면 다시 받기
 * 캐시 제어 로직을 서버에서 완전히 관리
 * 클라이언트는 단순히 이 값을 서버에 제공(클라이언트는 캐시 메커니즘을 모름)

 






 
